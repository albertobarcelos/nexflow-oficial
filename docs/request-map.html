<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mapa de APIs – NextFlow CRM</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet" />
    <style>
      :root {
        --bg: #ffffff;
        --text: #111827;
        --muted: #6b7280;
        --primary: #111827;
        --group: #0ea5e9;
        --flow: #7c3aed;
        --endpoint: #22c55e;
        --link: #334155;
        --critical: #ef4444;
        --m-get: #0ea5e9; /* GET */
        --m-post: #22c55e; /* POST */
        --m-put: #f59e0b; /* PUT */
        --m-delete: #ef4444; /* DELETE */
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: Poppins; /* regra do projeto: usar Poppins sem fallback */
        background: var(--bg);
        color: var(--text);
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid #e5e7eb;
      }
      .title { font-weight: 600; letter-spacing: 0.2px; }
      .toolbar { display: flex; gap: 8px; }
      .btn {
        font-family: Poppins;
        font-weight: 500;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        padding: 8px 12px;
        background: #fff;
        cursor: pointer;
      }
      .btn:hover { background: #f8fafc; }
      .btn[aria-pressed="true"] { background: #111827; color: #fff; border-color: #111827; }
      .filters { display: flex; flex-wrap: wrap; gap: 8px; padding: 10px 16px; border-bottom: 1px solid #e5e7eb; align-items: center; }
      .filters .group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      .filters .label { font-weight: 600; color: var(--primary); margin-right: 4px; }
      .method-dot { vertical-align: middle; margin-right: 6px; }
      #container { height: calc(100% - 54px); }
      svg { width: 100%; height: 100%; display: block; }
      .card-title { font-weight: 600; }
      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(17,24,39,0.6);
        z-index: 10;
        font-family: Poppins;
      }
      .overlay-content {
        width: 640px;
        max-width: 90vw;
        background: #fff;
        border-radius: 14px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.25);
        padding: 20px 22px;
      }
      .overlay h2 { margin: 0 0 8px 0; font-weight: 700; }
      .overlay p { margin: 6px 0; color: var(--muted); }
      .overlay .row { display: flex; justify-content: flex-end; gap: 8px; margin-top: 12px; }
    </style>
  </head>
  <body>
    <header>
      <div class="title">NextFlow CRM – Mapa de APIs</div>
      <div class="toolbar">
        <button class="btn" id="resetBtn">Resetar zoom</button>
        <button class="btn" id="downloadBtn">Salvar PNG</button>
      </div>
    </header>
    <!-- Filtros de visualização -->
    <div id="filters" class="filters" role="group" aria-label="Filtros do mapa">
      <div class="group" id="methodFilters">
        <span class="label">Métodos:</span>
        <button type="button" class="btn" data-method="GET" aria-pressed="true">
          <svg class="method-dot" width="10" height="10" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="10" height="10" fill="var(--m-get)"/></svg>
          GET
        </button>
        <button type="button" class="btn" data-method="POST" aria-pressed="true">
          <svg class="method-dot" width="10" height="10" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="10" height="10" fill="var(--m-post)"/></svg>
          POST
        </button>
        <button type="button" class="btn" data-method="PUT" aria-pressed="true">
          <svg class="method-dot" width="10" height="10" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="10" height="10" fill="var(--m-put)"/></svg>
          PUT
        </button>
        <button type="button" class="btn" data-method="DELETE" aria-pressed="true">
          <svg class="method-dot" width="10" height="10" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="10" height="10" fill="var(--m-delete)"/></svg>
          DELETE
        </button>
      </div>
      <div class="group" id="groupFilters">
        <span class="label">Grupos:</span>
        <!-- Botões serão gerados dinamicamente -->
      </div>
      <div class="group" id="extraFilters">
        <button type="button" class="btn" id="criticalOnly" aria-pressed="false" aria-label="Mostrar apenas endpoints críticos">Críticos</button>
        <button type="button" class="btn" id="singleGroupMode" aria-pressed="false" aria-label="Alternar seleção única de grupos">Modo único</button>
      </div>
    </div>
    <div id="container">
      <svg id="svg" viewBox="0 0 2400 1350" preserveAspectRatio="xMidYMid meet" aria-label="Mapa de APIs">
        <defs>
          <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
            <path d="M0,0 L10,3 L0,6" fill="var(--link)"></path>
          </marker>
        </defs>
        <g id="viewport"></g>
      </svg>
    </div>

    <div id="overlay" class="overlay" role="dialog" aria-modal="true">
      <div class="overlay-content">
        <h2>Erro ao carregar o mapa</h2>
        <p>Não foi possível obter <code>docs/api-map.json</code>.</p>
        <p>Verifique a disponibilidade do arquivo e tente novamente.</p>
        <div class="row">
          <button id="retryBtn" class="btn">Tentar novamente</button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/d3@7.9.0/dist/d3.min.js"></script>
    <script>
      const svg = document.getElementById('svg');
      const viewport = d3.select('#viewport');
      const overlay = document.getElementById('overlay');
      const retryBtn = document.getElementById('retryBtn');
      const resetBtn = document.getElementById('resetBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const groupFiltersEl = document.getElementById('groupFilters');
      const methodFiltersEl = document.getElementById('methodFilters');
      const criticalOnlyBtn = document.getElementById('criticalOnly');
      const singleGroupModeBtn = document.getElementById('singleGroupMode');

      // Estado dos filtros com persistência via querystring
      const FILTER_STATE = {
        methods: new Set(['GET','POST','PUT','DELETE']),
        groups: new Set(),
        criticalOnly: false,
        singleGroupMode: false
      };

      function parseSearch() {
        const sp = new URLSearchParams(window.location.search);
        const m = sp.get('m');
        const g = sp.get('g');
        const crit = sp.get('crit');
        const sg = sp.get('sg');
        if (m) FILTER_STATE.methods = new Set(m.split(',').filter(Boolean));
        if (g) FILTER_STATE.groups = new Set(g.split(',').filter(Boolean));
        FILTER_STATE.criticalOnly = crit === '1';
        FILTER_STATE.singleGroupMode = sg === '1';
      }

      function updateSearch() {
        const sp = new URLSearchParams();
        if (FILTER_STATE.methods.size && FILTER_STATE.methods.size < 4) sp.set('m', [...FILTER_STATE.methods].join(','));
        if (FILTER_STATE.groups.size) sp.set('g', [...FILTER_STATE.groups].join(','));
        if (FILTER_STATE.criticalOnly) sp.set('crit','1');
        if (FILTER_STATE.singleGroupMode) sp.set('sg','1');
        const qs = sp.toString();
        history.replaceState(null, '', qs ? ('?' + qs) : window.location.pathname);
      }

      retryBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        load();
      });

      resetBtn.addEventListener('click', () => {
        viewport.transition().duration(300).attr('transform', 'translate(0,0) scale(1)');
      });

      downloadBtn.addEventListener('click', () => downloadPNG());

      const zoom = d3.zoom().scaleExtent([0.5, 3]).on('zoom', (event) => {
        viewport.attr('transform', event.transform);
      });
      d3.select(svg).call(zoom);

      async function load() {
        try {
          const res = await fetch('./api-map.json', { cache: 'no-cache' });
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          parseSearch();
          buildFiltersUI(data);
          render(data);
        } catch (err) {
          overlay.style.display = 'flex';
          console.error('Falha ao carregar api-map.json:', err);
        }
      }

      function render(data) {
        viewport.selectAll('*').remove();
        const cfg = Object.assign({
          textSizePx: 12,
          minSpacingCm: 1.5
        }, data.layoutConfig || {});

        const canvas = (data.layout && data.layout.canvas) || { width: 2400, height: 1350 };
        svg.setAttribute('viewBox', `0 0 ${canvas.width} ${canvas.height}`);

        const groupPos = data.layout?.groups || {};
        const nodePos = data.layout?.nodes || {};
        const flowPos = data.layout?.flows || {};

        const scale = 1; // base scale, responsivo via viewBox
        const card = { w: 190, h: 72, rx: 10 };

        // Desenha grupos (círculos)
        const groups = new Map((data.groups || []).map(g => [g.id, g]));
        const groupLayer = viewport.append('g').attr('id', 'groups');
        const groupElements = new Map();
        groups.forEach((group, id) => {
          const p = groupPos[id] || { cx: canvas.width/2, cy: canvas.height/2, r: 200 };
          const circle = groupLayer.append('circle')
            .attr('cx', p.cx).attr('cy', p.cy).attr('r', p.r)
            .attr('fill', 'none').attr('stroke', 'var(--group)').attr('stroke-width', 2);
          const label = groupLayer.append('text')
            .attr('x', p.cx).attr('y', p.cy - p.r - 12)
            .attr('text-anchor', 'middle').attr('font-size', cfg.textSizePx + 2)
            .attr('font-weight', 600).text(group.label);
          groupElements.set(id, { circle, label });
        });

        // Desenha flows (cards)
        const flows = new Map((data.flows || []).map(f => [f.id, f]));
        const flowLayer = viewport.append('g').attr('id', 'flows');
        const flowElements = new Map();
        flows.forEach((flow, id) => {
          const p = flowPos[id] || { x: 100, y: 100 };
          const el = drawCard(flowLayer, p.x, p.y, flow.label, 'flow');
          el.attr('data-kind','flow').attr('data-id', id);
          flowElements.set(id, el);
        });

        // Desenha endpoints (cards)
        const nodeLayer = viewport.append('g').attr('id', 'nodes');
        const nodeElements = new Map();
        const nodesMap = new Map((data.nodes || []).map(n => [n.id, n]));
        (data.nodes || []).forEach(node => {
          const p = nodePos[node.id] || { x: canvas.width/2, y: canvas.height/2 };
          const el = drawCard(nodeLayer, p.x, p.y, node.label, 'endpoint', node.critical);
          const methods = (node.methods || []).map(m => m.method).join(',');
          el.attr('data-kind','endpoint').attr('data-id', node.id).attr('data-group', node.group).attr('data-methods', methods).attr('data-critical', node.critical ? '1' : '0');
          nodeElements.set(node.id, el);
        });

        // Desenha links
        const linkLayer = viewport.append('g').attr('id', 'links');
        const linkElements = [];
        (data.links || []).forEach(link => {
          const s = flowPos[link.source] || nodePos[link.source];
          const t = nodePos[link.target] || flowPos[link.target];
          if (!s || !t) return;
          const sx = s.x + card.w/2, sy = s.y + card.h/2;
          const tx = t.x + card.w/2, ty = t.y + card.h/2;
          const path = `M ${sx} ${sy} L ${tx} ${ty}`;
          const el = linkLayer.append('path')
            .attr('d', path)
            .attr('fill', 'none')
            .attr('stroke', link.critical ? 'var(--critical)' : 'var(--link)')
            .attr('stroke-width', 1.6)
            .attr('marker-end', 'url(#arrow)');
          linkElements.push({ el, source: link.source, target: link.target, method: link.method, critical: !!link.critical });
        });
        // Aplica filtros iniciais e guarda contexto
        applyFilters({ nodeElements, flowElements, linkElements, nodesMap, groupElements });
        window.__MAP_CTX__ = { nodeElements, flowElements, linkElements, nodesMap, groupElements };
      }

      function drawCard(layer, x, y, label, kind, critical = false) {
        const card = { w: 190, h: 72, rx: 10 };
        const color = kind === 'flow' ? 'var(--flow)' : 'var(--endpoint)';
        const g = layer.append('g').attr('transform', `translate(${x},${y})`);
        g.append('rect')
          .attr('width', card.w).attr('height', card.h).attr('rx', card.rx)
          .attr('fill', '#fff').attr('stroke', critical ? 'var(--critical)' : color)
          .attr('stroke-width', critical ? 2.4 : 1.6);
        g.append('text')
          .attr('x', 12).attr('y', 28)
          .attr('font-size', 14).attr('font-weight', 600)
          .text(label);
        return g;
      }

      // ==== Filtros: UI e aplicação ====
      function buildFiltersUI(data) {
        // Inicializa grupos (todos selecionados, salvo se vier na URL)
        const allGroupIds = (data.groups || []).map(g => g.id);
        if (!FILTER_STATE.groups.size) {
          allGroupIds.forEach(id => FILTER_STATE.groups.add(id));
        }

        // Constrói botões de grupos
        groupFiltersEl.innerHTML = '<span class="label">Grupos:</span>';
        (data.groups || []).forEach(g => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn';
          btn.textContent = g.label;
          btn.setAttribute('aria-pressed', FILTER_STATE.groups.has(g.id) ? 'true' : 'false');
          btn.dataset.group = g.id;
          groupFiltersEl.appendChild(btn);
        });

        // Reflete estado dos extras
        criticalOnlyBtn.setAttribute('aria-pressed', FILTER_STATE.criticalOnly ? 'true' : 'false');
        singleGroupModeBtn.setAttribute('aria-pressed', FILTER_STATE.singleGroupMode ? 'true' : 'false');

        // Eventos de método
        methodFiltersEl.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-method]');
          if (!btn) return;
          const m = btn.dataset.method;
          const pressed = btn.getAttribute('aria-pressed') === 'true';
          const next = !pressed;
          btn.setAttribute('aria-pressed', next ? 'true' : 'false');
          if (next) FILTER_STATE.methods.add(m); else FILTER_STATE.methods.delete(m);
          if (FILTER_STATE.methods.size === 0) { // garantir ao menos um método
            FILTER_STATE.methods.add(m);
            btn.setAttribute('aria-pressed','true');
          }
          updateSearch();
          if (window.__MAP_CTX__) applyFilters(window.__MAP_CTX__);
        });

        // Eventos de grupo
        groupFiltersEl.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-group]');
          if (!btn) return;
          const id = btn.dataset.group;
          if (FILTER_STATE.singleGroupMode) {
            FILTER_STATE.groups = new Set([id]);
            groupFiltersEl.querySelectorAll('button[data-group]').forEach(b => b.setAttribute('aria-pressed', b === btn ? 'true' : 'false'));
          } else {
            const pressed = btn.getAttribute('aria-pressed') === 'true';
            const next = !pressed;
            btn.setAttribute('aria-pressed', next ? 'true' : 'false');
            if (next) FILTER_STATE.groups.add(id); else FILTER_STATE.groups.delete(id);
            if (FILTER_STATE.groups.size === 0) { // garantir ao menos um grupo
              FILTER_STATE.groups.add(id);
              btn.setAttribute('aria-pressed','true');
            }
          }
          updateSearch();
          if (window.__MAP_CTX__) applyFilters(window.__MAP_CTX__);
        });

        criticalOnlyBtn.addEventListener('click', () => {
          const pressed = criticalOnlyBtn.getAttribute('aria-pressed') === 'true';
          const next = !pressed;
          criticalOnlyBtn.setAttribute('aria-pressed', next ? 'true' : 'false');
          FILTER_STATE.criticalOnly = next;
          updateSearch();
          if (window.__MAP_CTX__) applyFilters(window.__MAP_CTX__);
        });

        singleGroupModeBtn.addEventListener('click', () => {
          const pressed = singleGroupModeBtn.getAttribute('aria-pressed') === 'true';
          const next = !pressed;
          singleGroupModeBtn.setAttribute('aria-pressed', next ? 'true' : 'false');
          FILTER_STATE.singleGroupMode = next;
          updateSearch();
        });
      }

      function applyFilters(ctx) {
        const { nodeElements, linkElements, groupElements, nodesMap } = ctx;
        // Endpoints
        nodeElements.forEach((el, id) => {
          const node = nodesMap.get(id);
          const methods = (node.methods || []).map(m => m.method);
          const groupId = node.group;
          const critical = !!node.critical;
          const methodMatch = methods.some(m => FILTER_STATE.methods.has(m));
          const groupMatch = FILTER_STATE.groups.has(groupId);
          const criticalMatch = FILTER_STATE.criticalOnly ? critical : true;
          const visible = methodMatch && groupMatch && criticalMatch;
          el.style('display', visible ? null : 'none');
        });
        // Grupos
        groupElements.forEach((els, gid) => {
          const show = FILTER_STATE.groups.has(gid);
          els.circle.style('display', show ? null : 'none');
          els.label.style('display', show ? null : 'none');
        });
        // Links (exibidos se método ativo e alvo visível)
        linkElements.forEach((ln) => {
          const methodMatch = FILTER_STATE.methods.has(ln.method);
          const targetEl = ctx.nodeElements.get(ln.target);
          const targetVisible = targetEl && targetEl.node().style.display !== 'none';
          const visible = methodMatch && targetVisible;
          ln.el.style('display', visible ? null : 'none');
        });
      }

      function downloadPNG() {
        const serializer = new XMLSerializer();
        const src = serializer.serializeToString(svg);
        const svgBlob = new Blob([src], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const vb = svg.getAttribute('viewBox').split(' ').map(Number);
          canvas.width = vb[2];
          canvas.height = vb[3];
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          URL.revokeObjectURL(url);
          canvas.toBlob((blob) => {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'nextflow-api-map.png';
            a.click();
          }, 'image/png');
        };
        img.src = url;
      }

      load();
    </script>
  </body>
  </html>